{"code":"!function(e){var r={};function t(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&r&&\"string\"!=typeof e)for(var a in e)t.d(n,a,function(r){return e[r]}.bind(null,a));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p=\"\",t(t.s=\"./src/server/server.ts\")}({\"./plugins sync recursive ^\\\\.\\\\/.*\\\\/server\\\\/.*$\":\n/*!*******************************************!*\\\n  !*** ./plugins sync ^\\.\\/.*\\/server\\/.*$ ***!\n  \\*******************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval('var map = {\\n\\t\"./character/server/server\": \"./plugins/character/server/server.ts\",\\n\\t\"./character/server/server.ts\": \"./plugins/character/server/server.ts\"\\n};\\n\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\treturn __webpack_require__(id);\\n}\\nfunction webpackContextResolve(req) {\\n\\tif(!__webpack_require__.o(map, req)) {\\n\\t\\tvar e = new Error(\"Cannot find module \\'\" + req + \"\\'\");\\n\\t\\te.code = \\'MODULE_NOT_FOUND\\';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn map[req];\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = \"./plugins sync recursive ^\\\\\\\\.\\\\\\\\/.*\\\\\\\\/server\\\\\\\\/.*$\";\\n\\n//# sourceURL=webpack:///./plugins_sync_^\\\\.\\\\/.*\\\\/server\\\\/.*$?')},\"./plugins/character/server/server.ts\":\n/*!********************************************!*\\\n  !*** ./plugins/character/server/server.ts ***!\n  \\********************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nexports._handler = void 0;\\r\\nclass Module {\\r\\n    constructor(Koi) {\\r\\n        this.saveCharacter = (data) => __awaiter(this, void 0, void 0, function* () {\\r\\n            const player = global.source;\\r\\n            const playerIds = this.Koi.getPlayerIds(player);\\r\\n            const char = yield this.Koi.db(\"characters\").findFirst({\\r\\n                where: {\\r\\n                    id: playerIds.steam,\\r\\n                },\\r\\n            });\\r\\n            if (!char) {\\r\\n                return yield this.Koi.db(\"characters\").write({\\r\\n                    data: {\\r\\n                        skin: JSON.stringify(data),\\r\\n                    },\\r\\n                });\\r\\n            }\\r\\n            else {\\r\\n                return yield this.Koi.db(\"characters\").update({\\r\\n                    data: {\\r\\n                        skin: JSON.stringify(data),\\r\\n                    },\\r\\n                    where: {\\r\\n                        user_id: playerIds.steam,\\r\\n                    },\\r\\n                });\\r\\n            }\\r\\n        });\\r\\n        this.Koi = Koi;\\r\\n        Koi.onNet(\"character:save\", this.saveCharacter);\\r\\n    }\\r\\n}\\r\\nconst _handler = (koi) => new Module(koi);\\r\\nexports._handler = _handler;\\r\\n\\n\\n//# sourceURL=webpack:///./plugins/character/server/server.ts?')},\"./src/server/crypter.ts\":\n/*!*******************************!*\\\n  !*** ./src/server/crypter.ts ***!\n  \\*******************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\\r\\nclass CrypterWrapper {\\r\\n    constructor(algorithm, secretKey) {\\r\\n        this.encrypt = (text) => {\\r\\n            const cipher = crypto_1.createCipheriv(this.algorithm, this.secretKey, this.iv);\\r\\n            const encrypted = Buffer.concat([cipher.update(text), cipher.final()]);\\r\\n            return encrypted.toString(\"hex\");\\r\\n        };\\r\\n        this.decrypt = (hash) => {\\r\\n            const decipher = crypto_1.createDecipheriv(this.algorithm, this.secretKey, Buffer.from(hash.iv, \"hex\"));\\r\\n            const decrpyted = Buffer.concat([decipher.update(Buffer.from(hash.content, \"hex\")), decipher.final()]);\\r\\n            return decrpyted.toString();\\r\\n        };\\r\\n        this.algorithm = algorithm || \"aes-256-ctr\";\\r\\n        this.secretKey = secretKey || \"vOVH6sdmpNWjRRIqCc7rdxs01lwHzfr3\";\\r\\n        this.iv = crypto_1.randomBytes(16);\\r\\n    }\\r\\n}\\r\\nconst Crypter = (algorithm, secretKey) => new CrypterWrapper(algorithm, secretKey);\\r\\nexports.default = Crypter;\\r\\n\\n\\n//# sourceURL=webpack:///./src/server/crypter.ts?')},\"./src/server/database.ts\":\n/*!********************************!*\\\n  !*** ./src/server/database.ts ***!\n  \\********************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nclass DatabaseWrapper {\\r\\n    /**\\r\\n     * Nested data for the class\\r\\n     * @param table String\\r\\n     */\\r\\n    constructor(connection, table) {\\r\\n        /**\\r\\n         * Write a data into database table\\r\\n         * @param obj Object\\r\\n         * @returns result\\r\\n         */\\r\\n        this.write = (obj) => {\\r\\n            if (this.utils.validateQueryObject(obj, [\"data\"])) {\\r\\n                const keys = Object.keys(obj.data)\\r\\n                    .map((x) => this.parser.key(x))\\r\\n                    .join(\",\");\\r\\n                const values = Object.values(obj.data).join(\",\");\\r\\n                const query = `INSERT INTO \\\\`users\\\\`(${keys}) VALUES (${values})`;\\r\\n                return this.utils.executeQuery(query);\\r\\n            }\\r\\n        };\\r\\n        /**\\r\\n         * Find a data from database table\\r\\n         * @param obj Object\\r\\n         * @returns result\\r\\n         */\\r\\n        this.find = (obj) => {\\r\\n            if (this.utils.validateQueryObject(obj, [\"where\"])) {\\r\\n                let query;\\r\\n                if (obj.where) {\\r\\n                    const whereOptions = this.parser.keyVal(obj.where);\\r\\n                    query = `SELECT * FROM \\\\`${this.table}\\\\` WHERE ${whereOptions}`;\\r\\n                }\\r\\n                else {\\r\\n                    query = `SELECT * FROM \\\\`${this.table}\\\\``;\\r\\n                }\\r\\n                return this.utils.executeQuery(query);\\r\\n            }\\r\\n        };\\r\\n        /**\\r\\n         * Find first data from database table\\r\\n         * @param obj Object\\r\\n         * @returns result\\r\\n         */\\r\\n        this.findFirst = (obj) => __awaiter(this, void 0, void 0, function* () {\\r\\n            if (this.utils.validateQueryObject(obj, [\"where\"])) {\\r\\n                const result = yield this.find(obj);\\r\\n                return result && result.length > 0 ? result[0] : false;\\r\\n            }\\r\\n        });\\r\\n        /**\\r\\n         * Update a data from database table\\r\\n         * @param obj Object\\r\\n         * @returns result\\r\\n         */\\r\\n        this.update = (obj) => {\\r\\n            if (this.utils.validateQueryObject(obj, [\"data\", \"where\"])) {\\r\\n                const updateOptions = this.parser.keyVal(obj.data);\\r\\n                const whereOptions = this.parser.keyVal(obj.where);\\r\\n                const query = `UPDATE \\\\`${this.table}\\\\` SET ${updateOptions} WHERE ${whereOptions}`;\\r\\n                return this.utils.executeQuery(query);\\r\\n            }\\r\\n        };\\r\\n        /**\\r\\n         * Delete a data from database table\\r\\n         * @param obj Object\\r\\n         * @returns result\\r\\n         */\\r\\n        this.delete = (obj) => {\\r\\n            if (this.utils.validateQueryObject(obj, [\"where\"])) {\\r\\n                const whereOptions = this.parser.keyVal(obj.where);\\r\\n                const query = `DELETE FROM \\\\`${this.table}\\\\` WHERE ${whereOptions}`;\\r\\n                return this.utils.executeQuery(query);\\r\\n            }\\r\\n        };\\r\\n        this.parser = {\\r\\n            /**\\r\\n             * Put a templated string around the key for SQL to identified it as a structure name, not a value\\r\\n             * @param key String\\r\\n             * @returns `key`\\r\\n             */\\r\\n            key: (key) => `\\\\`${key}\\\\``,\\r\\n            /**\\r\\n             * Parsing object keys and it values to SQL key and value format and mapping it into a string format\\r\\n             * @param dataObj Object\\r\\n             * @returns `key`=value, `key2`=value, ...\\r\\n             */\\r\\n            keyVal: (dataObj) => Object.keys(dataObj).map((x) => {\\r\\n                const value = typeof dataObj[x] == \"string\" ? `\"${dataObj[x]}\"` : dataObj[x];\\r\\n                return `${this.parser.key(x)}=${value}`;\\r\\n            }),\\r\\n        };\\r\\n        this.utils = {\\r\\n            /**\\r\\n             * Validating query object before starting to execute it\\r\\n             * @param obj Object\\r\\n             * @returns Boolean(true) / Error\\r\\n             */\\r\\n            validateQueryObject: (obj, requiredKey = []) => {\\r\\n                if (typeof obj !== \"object\" || Array.isArray(obj)) {\\r\\n                    throw new Error(\"Database Query Object MUST be in object (JSON) type!\");\\r\\n                }\\r\\n                for (const key of requiredKey) {\\r\\n                    this.utils.validateQueryObjectData(key, obj[key]);\\r\\n                }\\r\\n                return true;\\r\\n            },\\r\\n            /**\\r\\n             * Validating object data whether if it\\'s object or not\\r\\n             * @param key String\\r\\n             * @param data Object\\r\\n             * @returns Boolean(true) / Error\\r\\n             */\\r\\n            validateQueryObjectData: (key, data) => {\\r\\n                if (typeof data !== \"undefined\" && (typeof data !== \"object\" || Array.isArray(data))) {\\r\\n                    throw new Error(\"Data of query object: `\" + key + \"` MUST be in object (JSON) type!\");\\r\\n                }\\r\\n                return true;\\r\\n            },\\r\\n            /**\\r\\n             * Executing database query in promise\\r\\n             * @param query String\\r\\n             * @returns result\\r\\n             */\\r\\n            executeQuery: (query) => __awaiter(this, void 0, void 0, function* () {\\r\\n                return new Promise((resolve, reject) => {\\r\\n                    this.connection.execute(query, (err, result, fields) => {\\r\\n                        if (err)\\r\\n                            reject(err);\\r\\n                        return resolve(result);\\r\\n                    });\\r\\n                });\\r\\n            }),\\r\\n        };\\r\\n        this.table = table;\\r\\n        this.connection = connection;\\r\\n    }\\r\\n}\\r\\nexports.default = DatabaseWrapper;\\r\\n\\n\\n//# sourceURL=webpack:///./src/server/database.ts?')},\"./src/server/server.ts\":\n/*!******************************!*\\\n  !*** ./src/server/server.ts ***!\n  \\******************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('\\r\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nvar __importDefault = (this && this.__importDefault) || function (mod) {\\r\\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\\r\\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\\r\\nconst database_1 = __importDefault(__webpack_require__(/*! ./database */ \"./src/server/database.ts\"));\\r\\nconst crypter_1 = __importDefault(__webpack_require__(/*! ./crypter */ \"./src/server/crypter.ts\"));\\r\\nclass Core {\\r\\n    constructor() {\\r\\n        this._initPlugins = () => {\\r\\n            const pluginsPath = path_1.default.join(GetResourcePath(GetCurrentResourceName()), \"plugins\");\\r\\n            fs_1.default.readdirSync(pluginsPath).map((resName) => {\\r\\n                try {\\r\\n                    fs_1.default.readdirSync(path_1.default.join(pluginsPath, resName, \"server\")).map((file) => __awaiter(this, void 0, void 0, function* () {\\r\\n                        const plugin = __webpack_require__(\"./plugins sync recursive ^\\\\\\\\.\\\\\\\\/.*\\\\\\\\/server\\\\\\\\/.*$\")(`./${resName}/server/${file}`);\\r\\n                        return plugin._handler(this);\\r\\n                    }));\\r\\n                }\\r\\n                catch (error) {\\r\\n                    return false;\\r\\n                }\\r\\n            });\\r\\n        };\\r\\n        this.registerCommand = (name, handler, config = false) => {\\r\\n            RegisterCommand(name, handler, config.restricted || false);\\r\\n            setImmediate(() => emitNet(\"chat:addSuggestion\", `/${name}`, config.description || \"No Description is Set\", config.argsDescription || []));\\r\\n            return true;\\r\\n        };\\r\\n        this.getPlayerIds = (src) => {\\r\\n            const playerIds = {};\\r\\n            for (let i = 0; i < GetNumPlayerIdentifiers(src); i++) {\\r\\n                const id = GetPlayerIdentifier(src, i).split(\":\");\\r\\n                playerIds[id[0]] = id[1];\\r\\n            }\\r\\n            playerIds.steam = BigInt(`0x${playerIds.steam}`);\\r\\n            return playerIds;\\r\\n        };\\r\\n        this.eventHandler = {\\r\\n            playerConnecting: (name, setKickReason, deferrals) => __awaiter(this, void 0, void 0, function* () {\\r\\n                deferrals.defer();\\r\\n                const player = global.source;\\r\\n                deferrals.update(`[🎏 Koi] Hello ${name}! Please wait until we verify your account.`);\\r\\n                const playerIds = this.getPlayerIds(player);\\r\\n                if (!playerIds.steam) {\\r\\n                    return deferrals.done(\"[🎏 Koi] You are not connected to Steam!\");\\r\\n                }\\r\\n                deferrals.update(`[🎏 Koi] Finding your account in our database.`);\\r\\n                const user = yield database_1.default(\"users\").findFirst({\\r\\n                    where: {\\r\\n                        id: playerIds.steam,\\r\\n                    },\\r\\n                });\\r\\n                let userCheck = false;\\r\\n                if (!user) {\\r\\n                    userCheck = yield database_1.default(\"users\").write({\\r\\n                        data: {\\r\\n                            id: playerIds.steam,\\r\\n                            last_ip: playerIds.ip.toString(),\\r\\n                            last_login: new Date().toLocaleString(\"en-US\", { timeZone: \"Asia/Jakarta\" }).toString(),\\r\\n                        },\\r\\n                    });\\r\\n                }\\r\\n                else {\\r\\n                    if (user.banned) {\\r\\n                        return deferrals.done(`[🎏 Koi] ⛔ You are banned from the server, Reason: ${user.banned_reason}`);\\r\\n                    }\\r\\n                    userCheck = yield database_1.default(\"users\").update({\\r\\n                        data: {\\r\\n                            last_ip: playerIds.ip.toString(),\\r\\n                            last_login: new Date().toLocaleString(\"en-US\", { timeZone: \"Asia/Jakarta\" }).toString(),\\r\\n                        },\\r\\n                        where: {\\r\\n                            id: playerIds.steam,\\r\\n                        },\\r\\n                    });\\r\\n                }\\r\\n                if (userCheck)\\r\\n                    return deferrals.done();\\r\\n            }),\\r\\n        };\\r\\n        this.db = database_1.default;\\r\\n        this.crypter = crypter_1.default;\\r\\n        this.on = on;\\r\\n        this.onNet = onNet;\\r\\n        this.emit = emit;\\r\\n        this.emitNet = emitNet;\\r\\n        onNet(\"Koi:registerCommand\", this.registerCommand);\\r\\n        onNet(\"Koi:getPlayerIds\", this.getPlayerIds);\\r\\n        on(\"playerConnecting\", this.eventHandler.playerConnecting);\\r\\n        this._initPlugins();\\r\\n    }\\r\\n}\\r\\nexports(\"getServerProps\", () => new Core());\\r\\n\\n\\n//# sourceURL=webpack:///./src/server/server.ts?')},crypto:\n/*!*************************!*\\\n  !*** external \"crypto\" ***!\n  \\*************************/\n/*! no static exports found */function(module,exports){eval('module.exports = require(\"crypto\");\\n\\n//# sourceURL=webpack:///external_%22crypto%22?')},fs:\n/*!*********************!*\\\n  !*** external \"fs\" ***!\n  \\*********************/\n/*! no static exports found */function(module,exports){eval('module.exports = require(\"fs\");\\n\\n//# sourceURL=webpack:///external_%22fs%22?')},path:\n/*!***********************!*\\\n  !*** external \"path\" ***!\n  \\***********************/\n/*! no static exports found */function(module,exports){eval('module.exports = require(\"path\");\\n\\n//# sourceURL=webpack:///external_%22path%22?')}});","extractedComments":[]}